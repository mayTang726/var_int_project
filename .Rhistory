select(id, transcript_consequences)
response_result_new <- response_result_new %>%
unnest(transcript_consequences)
# because the presiction based on amino acids variation, so just need to match transcriptid 和 amino acids
# connect transcriptid, protein_start, amino_acids value to hgvsp str for matching hg19_df
create_hgvsp <- function(amino_acids, start_pos) {
codon_split <- strsplit(amino_acids, "/")[[1]]
paste0(codon_split[1], start_pos, codon_split[2])
}
# check if protein_start equal protein_end，create hgvsp column
# mutate() from dplyr package, function: add new column / modify existed column
response_result_new <- response_result_new %>%
mutate(hgvsp = ifelse(protein_start == protein_end,
create_hgvsp(amino_acids, protein_start),
NA
))
#### match varsome resposne based on transcriptid, amino acids variatoin
# abstract sift information and transcript_id, hgvsp(one letter)
response_result_new_select <- response_result_new %>%
select(transcript_id, hgvsp, sift_prediction)
# %>% rename(
#       score_original = sift_score,
#       pre_original = sift_prediction
#     ) %>%
#     distinct()
# left_join combine matched rows
# hg19_df <- hg19_df %>%
#   mutate(
#     sift_score_original = NA,
#     sift_pre_original = NA
#   )
merged_df <- left_join(hg19_df, response_result_new_select,
by = c("ensembl_name" = "transcript_id", "ensembl_hgvs_p1" = "hgvsp"),
relationship = "many-to-many"
)
View(merged_df)
source("Rcode/resolve_varsome_response.R")
source("Rcode/db_connect_common.R")
## connect cosmic
db_type <- "SIFT" # 到时候要修改为动态的
# API address ： https://rest.ensembl.org/documentation/info/vep_hgvs_post
sift_url <- "https://grch37.rest.ensembl.org/vep/human/hgvs"
# request body prepare
## combine ensembl_name and hgvs as a string and put it to the list
sift_request_body_list <- hg19_df %>%
filter(!is.na(ensembl_name) & !is.na(ensembl_hgvs)) %>%
mutate(combined = paste(ensembl_name, ensembl_hgvs, sep = ":")) %>%
distinct(combined) %>%
pull(combined)
print(sift_request_body_list)
# dbname, host, port, user, password, API, parameter_num
sift_obj <- list(
API = TRUE,
param_type = "SIFT",
url = sift_url,
req_type = "POST",
body = sift_request_body_list
)
# calculate score
response_result <- data.frame()
result_resolve <- function(search_result, db_type) {
print("进入回调中")
# parse response to dataframe
response_result <- search_result$response_data[[1]]
response_result <- fromJSON(response_result)
response_result <<- as.data.frame(response_result)
# abstract transcription column for matching varsome response
response_result_new <- data.frame()
response_result_new <- response_result %>%
select(id, transcript_consequences)
response_result_new <- response_result_new %>%
unnest(transcript_consequences)
# because the presiction based on amino acids variation, so just need to match transcriptid 和 amino acids
# connect transcriptid, protein_start, amino_acids value to hgvsp str for matching hg19_df
create_hgvsp <- function(amino_acids, start_pos) {
codon_split <- strsplit(amino_acids, "/")[[1]]
paste0(codon_split[1], start_pos, codon_split[2])
}
# check if protein_start equal protein_end，create hgvsp column
# mutate() from dplyr package, function: add new column / modify existed column
response_result_new <- response_result_new %>%
mutate(hgvsp = ifelse(protein_start == protein_end,
create_hgvsp(amino_acids, protein_start),
NA
))
#### match varsome resposne based on transcriptid, amino acids variatoin
# abstract sift information and transcript_id, hgvsp(one letter)
response_result_new_select <- response_result_new %>%
select(transcript_id, hgvsp, sift_prediction)
# %>% rename(
#       score_original = sift_score,
#       pre_original = sift_prediction
#     ) %>%
#     distinct()
# left_join combine matched rows
# hg19_df <- hg19_df %>%
#   mutate(
#     sift_score_original = NA,
#     sift_pre_original = NA
#   )
hg19_df <- left_join(hg19_df, response_result_new_select,
by = c("ensembl_name" = "transcript_id", "ensembl_hgvs_p1" = "hgvsp"),
relationship = "many-to-many"
)
# hg19_df <- merged_df %>%
#   mutate(
#     sift_score_original = if_else(is.na(sift_score_original), score_original, sift_score_original),
#     sift_pre_original = if_else(is.na(sift_pre_original), pre_original, sift_pre_original)
#   ) %>%
#   select(-pre_original, -score_original)
#### 有个问题： hg19_df中有多列，但是目前每个相同的值只在hg19_df中只match了一次，其他相同的都是NA，
#### 这个需要处理一下
}
# request function
db_check_fun <- function(db_type) {
search_result <- connect_function(sift_obj) # list[[1]]: param_type, list[[2]]: list ---> searched information
result_resolve(search_result, db_type)
}
db_check_fun(db_type)
View(response_result)
response_result_new <- data.frame()
response_result_new <- response_result %>%
select(id, transcript_consequences)
response_result_new <- response_result_new %>%
unnest(transcript_consequences)
# because the presiction based on amino acids variation, so just need to match transcriptid 和 amino acids
# connect transcriptid, protein_start, amino_acids value to hgvsp str for matching hg19_df
create_hgvsp <- function(amino_acids, start_pos) {
codon_split <- strsplit(amino_acids, "/")[[1]]
paste0(codon_split[1], start_pos, codon_split[2])
}
response_result_new <- response_result_new %>%
mutate(hgvsp = ifelse(protein_start == protein_end,
create_hgvsp(amino_acids, protein_start),
NA
))
response_result_new_select <- response_result_new %>%
select(transcript_id, hgvsp, sift_prediction)
View(response_result_new_select)
response_result_new_select <- response_result_new %>%
select(transcript_id, hgvsp, sift_prediction)
hg19_df <- left_join(hg19_df, response_result_new_select,
by = c("ensembl_name" = "transcript_id", "ensembl_hgvs_p1" = "hgvsp"),
relationship = "many-to-many"
)
View(hg19_df)
source("Rcode/db_connect_common.R")
## connect cosmic
db_type <- "mutation"  # 到时候要修改为动态的
mutation_url <- "https://www.genecascade.org/MT2021/MT_API102.cgi?variants="
#request body prepare
## the param need format - "<chromosome_number>:<position><pre>%3E<alt>"
## convert original tring to param format
convert_variant <- function(variant) {
# 移除 "chr" 前缀
variant <- sub("^chr", "", variant)
# 保留第一个冒号
first_char <- regexpr(":", variant)
first_part <- substr(variant, 1, first_char)
remaining_part <- substr(variant, first_char + 1, nchar(variant))
remaining_part <- sub(":(?=[^:]*$)", "%3E", remaining_part, perl = TRUE)
remaining_part <- gsub(":", "", remaining_part)
variant <- paste0(first_part, remaining_part)
return(variant)
}
# delete duplicated elements
mutation_request_body_list <- unique(convert_variant(hg19_df$original_variant))
print(mutation_request_body_list)
#dbname, host, port, user, password, API, parameter_num
mutation_obj <- list(
API = TRUE,
param_type = "mutation",
url = mutation_url,
req_type = "GET",
body = mutation_request_body_list
)
# calculate score
response_result_mutation <- data.frame()
result_resolve <- function(search_result,db_type) {
# print('进入回调中')
# print(search_result$response_data)
# output: polyphen_prediction(有害), Polymorphism(可能是无害的)
# resolve response format to df
response_result_mutation <<- as.data.frame(search_result$response_data)
base_names <- unique(gsub("\\..*", "", names(df)))
response_result_mutation_new <- response_result_mutation %>%
pivot_longer(
cols = everything(),
names_to = c(".value", "set"),
names_sep = "\\."
) %>%
select(-set)
# add chromosome variant column
response_result_mutation_new <- response_result_mutation_new %>%
mutate(chr_variant = paste0('chr',chr,':',pos,':',ref,':', alt))
# left useful column for matching gh19_df
response_result_mutation_new <- response_result_mutation_new %>%
select(chr_variant, prediction,transcript_stable)
# delete rows which are full NA
response_result_mutation_new <- response_result_mutation_new %>%
filter(rowSums(is.na(.)) < ncol(.))
print(colnames(response_result_mutation_new))
print(colnames(hg19_df))
# match with hg19_df
hg19_df <- left_join(hg19_df, response_result_mutation_new,
by = c("original_variant" = "chr_variant", "ensembl_name" = "transcript_stable"),
relationship = "many-to-many"
)
hg19_df <- hg19_df %>% rename(mutation_taster_prediction = prediction)
}
db_check_fun <- function(db_type) {
search_result <- connect_function(mutation_obj) # list[[1]]: param_type, list[[2]]: list ---> searched information
result_resolve(search_result,db_type)
}
db_check_fun(db_type)
response_result_mutation_new <- response_result_mutation %>%
pivot_longer(
cols = everything(),
names_to = c(".value", "set"),
names_sep = "\\."
) %>%
select(-set)
# add chromosome variant column
response_result_mutation_new <- response_result_mutation_new %>%
mutate(chr_variant = paste0('chr',chr,':',pos,':',ref,':', alt))
# left useful column for matching gh19_df
response_result_mutation_new <- response_result_mutation_new %>%
select(chr_variant, prediction,transcript_stable)
# delete rows which are full NA
response_result_mutation_new <- response_result_mutation_new %>%
filter(rowSums(is.na(.)) < ncol(.))
print(colnames(response_result_mutation_new))
print(colnames(hg19_df))
# match with hg19_df
hg19_df <- left_join(hg19_df, response_result_mutation_new,
by = c("original_variant" = "chr_variant", "ensembl_name" = "transcript_stable"),
relationship = "many-to-many"
)
hg19_df <- hg19_df %>% rename(mutation_taster_prediction = prediction)
print(unique(hg19_df$refseq_gene_symbol))
print(hg19_df$ncbi_clinvar2)
oncokb_queries_list <- list(
referenceGenome = "",
hugoSymbol = "BRAF",
entrezGeneId = "",
alteration = "V600E",
consequence = "",
proteinStart = "",
proteinEnd = "",
tumorType = ""
)
oncokb_queries_real <- paste0("referenceGenome=", oncokb_queries_list$referenceGenome,"&",
"hugoSymbol=", oncokb_queries_list$hugoSymbol, "&",
"entrezGeneId=", oncokb_queries_list$entrezGeneId, "&",
"alteration=", oncokb_queries_list$alteration,"&",
"consequence=", oncokb_queries_list$consequence,"&",
"proteinStart=", oncokb_queries_list$proteinStart,"&",
"proteinEnd=", oncokb_queries_list$proteinEnd,"&",
"tumorType=", oncokb_queries_list$tumorType)
print(oncokb_queries_params)
#request body prepare
oncokb_queries_list <- list(
referenceGenome = "",
hugoSymbol = "BRAF",
entrezGeneId = "",
alteration = "V600E",
consequence = "",
proteinStart = "",
proteinEnd = "",
tumorType = ""
)
oncokb_queries_params <- paste0("referenceGenome=", oncokb_queries_list$referenceGenome,"&",
"hugoSymbol=", oncokb_queries_list$hugoSymbol, "&",
"entrezGeneId=", oncokb_queries_list$entrezGeneId, "&",
"alteration=", oncokb_queries_list$alteration,"&",
"consequence=", oncokb_queries_list$consequence,"&",
"proteinStart=", oncokb_queries_list$proteinStart,"&",
"proteinEnd=", oncokb_queries_list$proteinEnd,"&",
"tumorType=", oncokb_queries_list$tumorType)
print(oncokb_queries_params)
bed_df = data.frame(chromosome,start_position,end_position,cosmic_id,score,strand,variant_info)
bed_lines <- readLines('./data/hotspot_region_Oncomine_Focus_DNA_Hotspots_v1.4_hg19.bed', encoding = "UTF-8")[-1]
bed_data <- read.table(text = bed_lines, header = FALSE, sep = "\t")
# change list to dataframe
bed_df <- data.frame(
chromosome = character(),
start_position = numeric(),
end_position = numeric(),
cosmic_id = character(),
score = numeric(),
strand = character(),
variant_info = character(),
stringsAsFactors = FALSE  # 确保字符型数据不会转换为因子
)
chromosome <- c(bed_data[1])
start_position <- c(bed_data[2])
end_position <- c(bed_data[3])
cosmic_id <- c(bed_data[4])
score <- c(bed_data[5])
strand <- c(bed_data[6])
variant_info <- c(bed_data[7])
bed_df = data.frame(chromosome,start_position,end_position,cosmic_id,score,strand,variant_info)
colnames(bed_df) <- c("chromosome", "start_position", "end_position", "cosmic_id", "score", "strand", "variant_info")
View(bed_df)
#get chr17 df
chr17_df <- subset(bed_df, chromosome == 'chr17')
View(chr17_df)
# 使用strsplit()函数将variant_info列的值分割成一个列表
split_info <- strsplit(chr17_df$variant_info, ";")
View(split_info)
bed_lines <- readLines('./data/hotspot_region_Oncomine_Focus_DNA_Hotspots_v1.4_hg19.bed', encoding = "UTF-8")[-1]
bed_data <- read.table(text = bed_lines, header = FALSE, sep = "\t")
# change list to dataframe
bed_df <- data.frame(
chromosome = character(),
start_position = numeric(),
end_position = numeric(),
cosmic_id = character(),
score = numeric(),
strand = character(),
variant_info = character(),
stringsAsFactors = FALSE  # 确保字符型数据不会转换为因子
)
chromosome <- c(bed_data[1])
start_position <- c(bed_data[2])
end_position <- c(bed_data[3])
cosmic_id <- c(bed_data[4])
score <- c(bed_data[5])
strand <- c(bed_data[6])
variant_info <- c(bed_data[7])
# whole df
bed_df = data.frame(chromosome,start_position,end_position,cosmic_id,score,strand,variant_info)
colnames(bed_df) <- c("chromosome", "start_position", "end_position", "cosmic_id", "score", "strand", "variant_info")
#get chr17 df
# chr17_df <- subset(bed_df, chromosome == 'chr17')
# 使用strsplit()函数将variant_info列的值分割成一个列表
split_info <- strsplit(bed_df$variant_info, ";")
# 初始化用于存储拆分值的向量
REF <- character(length = nrow(bed_df))
OBS <- character(length = nrow(bed_df))
ANCHOR <- character(length = nrow(bed_df))
# 从列表中提取REF，OBS和ANCHOR的值
for (i in 1:length(split_info)) {
for (j in 1:length(split_info[[i]])) {
if (grepl("^REF=", split_info[[i]][j])) {
REF[i] <- gsub("^REF=(.*)$", "\\1", split_info[[i]][j])
} else if (grepl("^OBS=", split_info[[i]][j])) {
OBS[i] <- gsub("^OBS=(.*)$", "\\1", split_info[[i]][j])
} else if (grepl("^ANCHOR=", split_info[[i]][j])) {
ANCHOR[i] <- gsub("^ANCHOR=(.*)$", "\\1", split_info[[i]][j])
}
}
}
# 创建REF，OBS和ANCHOR列，用于合成搜索内容
new_df <- data.frame(REF = REF, OBS = OBS, ANCHOR = ANCHOR)
# 将新的数据框添加到原始数据框中
bed_df <- cbind(bed_df, new_df)
bed_df$variant_info <- paste0(bed_df$ANCHOR, ":", bed_df$OBS)
bed_df$search_column <- apply(bed_df, 1, function(row){
paste(row['chromosome'],row['start_position'],row['variant_info'], sep = ':')
})
# chromosome variant position - based on hg19
varraint_array <- as.list(bed_df$search_column)
View(bed_df)
json_data <- toJSON(varraint_array,pretty = TRUE)
write(json_data,file="data/chr_position_varriant_array_hg19.txt")
#get chr17 df
chr17_df <- subset(bed_df, chromosome == 'chr17')
View(chr17_df)
varraint_array_chr17 <- as.list(chr17_df$search_column)
write(json_data,file="data/chr17_position_varriant_array_hg19.txt")
write(varraint_array_chr17,file="data/chr17_position_varriant_array_hg19.txt")
varraint_array_chr17 <- as.list(chr17_df$search_column)
write(varraint_array_chr17,file="data/chr17_position_varriant_array_hg19.txt")
chr17_df <- subset(bed_df, chromosome == 'chr17')
varraint_array_chr17 <- as.list(chr17_df$search_column)
write(varraint_array_chr17,file="data/chr17_position_varriant_array_hg19.txt")
View(bed_df)
View(chr17_df)
#get chr17 df
chr17_df <- subset(bed_df, chromosome == 'chr17')
varraint_array_chr17 <- as.list(chr17_df$search_column)
write(varraint_array_chr17,file="data/chr17_position_varriant_array_hg19.txt")
varraint_array_chr17 <- as.list(chr17_df$search_column)
json_data_chr17 <- toJSON(varraint_array_chr17,pretty = TRUE)
write(json_data_chr17,file="data/chr17_position_varriant_array_hg19.txt")
# this is the process of request the VarSome API, from request hg19, listover hg19 -> hg38, request hg38
getwd()
source("Rcode/db_connect_common.R") # request file
source("utils/request_body_resolve.R") # request body resolve function
# whole chromosome
varaint_array_hg19_whole <- readLines('data/chr_position_varriant_array_hg19.txt')
# chromosome 17
varaint_array_hg19 <- readLines('data/chr17_position_varriant_array_hg19.txt')
varaint_array_hg38 <- readLines('data/chr17_position_varriant_array_hg38.txt')
# entry object
db_type <- "varsome_19"  # 到时候要修改为动态的
varsome_url <- ""
if(db_type == "varsome_19"){
varsome_url <- "https://api.varsome.com/lookup/lifted-over-variant/"
}else if(db_type == 'varsome_19') {
varsome_url <- "https://api.varsome.com/lookup/batch/hg19?add-source-databases=all&add-ACMG-annotation=1&add-AMP-annotation=1"
}else if(db_type == 'varsome_38') {
varsome_url <- "https://api.varsome.com/lookup/batch/hg38?add-source-databases=all&add-ACMG-annotation=1&add-AMP-annotation=1"
}
varsome_19_obj <- list(
API = TRUE,
param_type = "varsome",
url = varsome_url,
req_type = "POST",
token = "Token W0beUnL?kAjoieM4ueklHW%p5AzMVaG@ju@8dD@y",
body = ''
)
varsome_38_obj <- list(
API = TRUE,
param_type = "varsome",
url = varsome_url,
req_type = "POST",
token = "Token W0beUnL?kAjoieM4ueklHW%p5AzMVaG@ju@8dD@y",
body = ''
)
varsome_liftover_obj <- list(
API = TRUE,
param_type = "varsome",
url = varsome_url,
req_type = "GET",
token = "Token W0beUnL?kAjoieM4ueklHW%p5AzMVaG@ju@8dD@y",
body = variant_list_liftover
)
# this is the process of request the VarSome API, from request hg19, listover hg19 -> hg38, request hg38
getwd()
source("Rcode/db_connect_common.R") # request file
source("utils/request_body_resolve.R") # request body resolve function
# whole chromosome
varaint_array_hg19_whole <- readLines('data/chr_position_varriant_array_hg19.txt')
# chromosome 17
varaint_array_hg19 <- readLines('data/chr17_position_varriant_array_hg19.txt')
varaint_array_hg38 <- readLines('data/chr17_position_varriant_array_hg38.txt')
# entry object
db_type <- "varsome_19"  # 到时候要修改为动态的
varsome_url <- ""
if(db_type == 'varsome_19') {
varsome_url <- "https://api.varsome.com/lookup/batch/hg19?add-source-databases=all&add-ACMG-annotation=1&add-AMP-annotation=1"
}else if(db_type == 'varsome_38') {
varsome_url <- "https://api.varsome.com/lookup/batch/hg38?add-source-databases=all&add-ACMG-annotation=1&add-AMP-annotation=1"
}
varsome_19_obj <- list(
API = TRUE,
param_type = "varsome",
url = varsome_url,
req_type = "POST",
token = "Token W0beUnL?kAjoieM4ueklHW%p5AzMVaG@ju@8dD@y",
body = ''
)
varsome_38_obj <- list(
API = TRUE,
param_type = "varsome",
url = varsome_url,
req_type = "POST",
token = "Token W0beUnL?kAjoieM4ueklHW%p5AzMVaG@ju@8dD@y",
body = ''
)
# calculate score
search_result <- list()
calculate_score <- function(search_result,db_type) {
print('callback')
if(db_type == 'varsome_liftover'){
library(jsonlite)
json_data <- toJSON(search_result,pretty = TRUE)
write(json_data,file="data/chr17_position_varriant_array_hg38.txt")
}else if (db_type == 'varsome_19') {
# write(search_result$response_data,'data/variant_response_hg19.json')
write(search_result$response_data,'data/whole_variant_response_hg19.json')
}else {
print(search_result$response_data)
write(search_result$response_data,'data/variant_response_hg38.json')
}
# search_result <- search_result
}
param <- ""
search_result <- ""
db_check_fun <- function(db_type) {
if(db_type == 'varsome_19') {
# varsome_19_obj$body <- request_body(varaint_array_hg19)
varsome_19_obj$body <- request_body(varaint_array_hg19_whole)
param <- varsome_19_obj
}else if(db_type == 'varsome_38') {
varsome_38_obj$body <- request_body(varaint_array_hg38)
param <- varsome_38_obj
}
search_result <- connect_function(param) # list[[1]]: param_type, list[[2]]: list ---> searched information
calculate_score(search_result,db_type)
}
db_check_fun(db_type)
Q
Q
View(hg19_df)
View(hg19_df)
View(hg19_df[[49]][[51]])
dff <- hg19_df
head(dff)
dim(dff)[1]
seq_along(dim(dff)[1]
)
View(hg19_df)
dplyr::select(.data = dff, !version) %>% head()
dplyr::select(.data = dff, !"version") %>% head()
dff$version
hg19_df %>%
unnest(refseq_transcripts) %>%
unnest(items) %>%
rename_with(~ paste0("refseq_", .), .cols = c("name", "strand", "coding_impact", "function", "hgvs", "hgvs_p1", "hgvs_p3", "location", "coding_location", "canonical", "gene_symbol", "splice_distance", "ensembl_support_level", "ensembl_appris", "mane_select", "mane_plus", "uniprot_id"))  # 为所有列添加前缀
